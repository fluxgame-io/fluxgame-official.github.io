<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DETECTIVE KABIR: FINAL CASE</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; }
        #crosshair { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 20px; pointer-events: none; z-index: 100; }
        .hud { position: fixed; bottom: 30px; left: 30px; color: #00f2ff; background: rgba(0,0,0,0.85); padding: 15px; border: 2px solid #00f2ff; border-radius: 5px; z-index: 100; }
        #msg { position: fixed; top: 20%; width: 100%; text-align: center; color: #ff0000; font-size: 28px; font-weight: bold; text-shadow: 2px 2px #000; display: none; z-index: 1000; }
        #inventory { position: fixed; top: 20px; right: 20px; color: #ffcc00; font-size: 14px; background: rgba(0,0,0,0.8); padding: 10px; border: 1px dashed #ffcc00; }
    </style>
</head>
<body>

    <div id="crosshair">+</div>
    <div id="msg">LOCKED</div>
    <div id="inventory">EVIDENCE: <span id="evidence-status">NOT FOUND</span></div>
    
    <div class="hud">
        <b>KABIR INVESTIGATION - CASE #1045</b><br>
        [WASD] Chalna | [SPACE] Bhagna | [F] Torch<br>
        [H] Interact / Examine / Rakhna
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer, torch, flowerPot;
        let yaw = new THREE.Object3D(), pitch = new THREE.Object3D();
        let moveF = 0, moveR = 0, isSprinting = false, isExamining = false;
        let colliders = [], interactables = [], roomLights = [];
        let hasCode = false;

        init();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            scene.fog = new THREE.FogExp2(0x000000, 0.04);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            yaw.add(pitch); pitch.add(camera); scene.add(yaw);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // 1. LIGHTS - HIGH INTENSITY (Brightness Fix)
            addBrightLight(0, 4, -7, 0); // Room 1
            addBrightLight(0, 4, 10, 1);  // Room 2

            // 2. FLOOR & CEILING
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(60, 60), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            floor.rotation.x = -Math.PI/2; floor.position.y = -2; floor.receiveShadow = true;
            scene.add(floor);

            // 3. WALLS & COLLISION BOUNDARIES
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
            createSolidWall(0, 1.5, -15, 20, 7, wallMat); // Back
            createSolidWall(-10, 1.5, 0, 30, 7, wallMat, true); // Left
            createSolidWall(10, 1.5, 0, 30, 7, wallMat, true); // Right
            createSolidWall(-6, 1.5, 0, 8, 7, wallMat); // Partition
            createSolidWall(6, 1.5, 0, 8, 7, wallMat);

            // 4. THE LOCKED DOOR
            const doorObj = new THREE.Mesh(new THREE.BoxGeometry(4, 5.5, 0.3), new THREE.MeshStandardMaterial({color: 0x4b2d1f}));
            doorObj.position.set(0, 0.75, 0); doorObj.userData = { type: 'door', isOpen: false };
            scene.add(doorObj); colliders.push(doorObj); interactables.push(doorObj);

            // 5. THE INVESTIGATION TABLE (Solid)
            createFurniture(0, -1.2, -8, 4, 1.8, 2.5, 0x4a2c16); 

            // 6. THE FLOWER POT (With Hidden Code)
            flowerPot = new THREE.Group();
            const potBase = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.3, 0.7, 12), new THREE.MeshStandardMaterial({color: 0xcd853f}));
            flowerPot.add(potBase);
            // Hidden Code under pot
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 128; canvas.height = 128;
            ctx.fillStyle = 'white'; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = 'black'; ctx.font = 'bold 30px Arial'; ctx.fillText("CODE", 25, 50);
            ctx.fillStyle = 'red'; ctx.font = 'bold 40px Arial'; ctx.fillText("1045", 20, 100);
            const codeTex = new THREE.CanvasTexture(canvas);
            const codeTag = new THREE.Mesh(new THREE.CircleGeometry(0.3, 16), new THREE.MeshStandardMaterial({map: codeTex}));
            codeTag.rotation.x = Math.PI/2; codeTag.position.y = -0.36;
            flowerPot.add(codeTag);
            flowerPot.position.set(0, -0.3, -8); // On the table
            scene.add(flowerPot); interactables.push(flowerPot);

            // 7. LIGHT SWITCHES (Red)
            createSwitch(-2.5, 1, -0.1, 0); 
            createSwitch(2.5, 1, 0.1, 1);

            // 8. PLAYER TOOLS
            torch = new THREE.SpotLight(0xffffff, 1.5, 35, Math.PI/6);
            camera.add(torch); torch.target.position.set(0,0,-1); camera.add(torch.target);

            setupControls();
            animate();
        }

        function addBrightLight(x, y, z, id) {
            const light = new THREE.PointLight(0xffffff, 25, 25);
            light.position.set(x, y, z); light.castShadow = true;
            scene.add(light); roomLights.push(light);
            const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({color: 0xffffcc}));
            bulb.position.set(x, y, z); scene.add(bulb);
        }

        function createSolidWall(x, y, z, w, h, mat, rot=false) {
            const wall = new THREE.Mesh(new THREE.PlaneGeometry(w, h), mat);
            wall.position.set(x, y, z); if(rot) wall.rotation.y = Math.PI/2;
            scene.add(wall);
            const box = new THREE.Mesh(new THREE.BoxGeometry(rot?0.5:w, h, rot?w:0.5));
            box.position.set(x, y, z); box.visible = false;
            scene.add(box); colliders.push(box); // Add to collision list
        }

        function createFurniture(x, y, z, w, h, d, col) {
            const f = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({color: col}));
            f.position.set(x, y, z); f.castShadow = true;
            scene.add(f); colliders.push(f); // Make it solid
        }

        function createSwitch(x, y, z, rId) {
            const sw = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.4, 0.1), new THREE.MeshStandardMaterial({color: 0xff0000}));
            sw.position.set(x, y, z); sw.userData = { type: 'switch', id: rId };
            scene.add(sw); interactables.push(sw);
        }

        function setupControls() {
            document.addEventListener('keydown', (e) => {
                const k = e.key.toLowerCase();
                if(k === 'w') moveF = 1; if(k === 's') moveF = -1;
                if(k === 'a') moveR = -1; if(k === 'd') moveR = 1;
                if(e.code === 'Space') isSprinting = true;
                if(k === 'f') torch.visible = !torch.visible;
                if(k === 'h') interact();
            });
            document.addEventListener('keyup', (e) => {
                const k = e.key.toLowerCase();
                if(['w','s'].includes(k)) moveF = 0; if(['a','d'].includes(k)) moveR = 0;
                if(e.code === 'Space') isSprinting = false;
            });
            document.addEventListener('pointermove', (e) => {
                if(isExamining) {
                    flowerPot.rotation.y += e.movementX * 0.01;
                    flowerPot.rotation.x += e.movementY * 0.01;
                } else if(document.pointerLockElement) {
                    yaw.rotation.y -= e.movementX * 0.002;
                    pitch.rotation.x -= e.movementY * 0.002;
                    pitch.rotation.x = Math.max(-1.5, Math.min(1.5, pitch.rotation.x));
                }
            });
            document.addEventListener('mousedown', () => { if(!isExamining) document.body.requestPointerLock(); });
        }

        function interact() {
            interactables.forEach(obj => {
                if(yaw.position.distanceTo(obj.position) < 4) {
                    if(obj === flowerPot) {
                        if(!isExamining) {
                            isExamining = true; moveF = moveR = 0;
                            flowerPot.userData.oldPos = flowerPot.position.clone();
                            flowerPot.userData.oldRot = flowerPot.rotation.clone();
                            camera.add(flowerPot); flowerPot.position.set(0, 0, -1.2);
                            hasCode = true; document.getElementById('evidence-status').innerText = "CODE 1045 ACQUIRED";
                        } else {
                            isExamining = false; scene.attach(flowerPot);
                            flowerPot.position.copy(flowerPot.userData.oldPos);
                            flowerPot.rotation.copy(flowerPot.userData.oldRot);
                        }
                    } else if(obj.userData.type === 'door') {
                        if(hasCode) {
                            obj.userData.isOpen = !obj.userData.isOpen;
                            obj.position.x = obj.userData.isOpen ? 4 : 0;
                            if(obj.userData.isOpen) colliders = colliders.filter(c => c !== obj);
                            else colliders.push(obj);
                        } else { showPop("DOOR IS LOCKED. NEED CODE!"); }
                    } else if(obj.userData.type === 'switch') {
                        roomLights[obj.userData.id].visible = !roomLights[obj.userData.id].visible;
                    }
                }
            });
        }

        function showPop(t) {
            const m = document.getElementById('msg'); m.innerText = t; m.style.display = "block";
            setTimeout(() => m.style.display = "none", 2000);
        }

        function animate() {
            requestAnimationFrame(animate);
            if(!isExamining) {
                let speed = isSprinting ? 0.22 : 0.09;
                if(moveF || moveR) {
                    const dir = new THREE.Vector3(moveR, 0, -moveF).normalize().applyQuaternion(yaw.quaternion);
                    const nextPos = yaw.position.clone().addScaledVector(dir, speed);
                    
                    // COLLISION CHECK
                    let canMove = true;
                    const pBox = new THREE.Box3().setFromCenterAndSize(nextPos, new THREE.Vector3(1, 4, 1));
                    for(let wall of colliders) {
                        if(pBox.intersectsBox(new THREE.Box3().setFromObject(wall))) {
                            canMove = false; break;
                        }
                    }
                    if(canMove) yaw.position.copy(nextPos);
                }
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
