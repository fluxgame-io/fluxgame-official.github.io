<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KABIR: LIGHTS & SWITCHES</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; touch-action: none; }
        #crosshair { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 24px; pointer-events: none; z-index: 100; }
        .hud { position: fixed; top: 10px; left: 10px; color: #00f2ff; background: rgba(0,0,0,0.7); padding: 12px; z-index: 100; font-size: 13px; pointer-events: none; border-left: 4px solid #00f2ff; }
        #msg { position: fixed; top: 20%; width: 100%; text-align: center; color: #00f2ff; display: none; z-index: 1000; font-weight: bold; background: rgba(0,0,0,0.5); padding: 10px; }
    </style>
</head>
<body>

    <div id="crosshair">+</div>
    <div id="msg"></div>
    
    <div id="hud" class="hud">
        <b>KABIR INVESTIGATION SYSTEM</b><br>
        [H] Switch/Door | [F] Flashlight | [TAB] Intensity<br>
        ROOM 1 LIGHT: <span id="r1-stat">ON</span> | ROOM 2: <span id="r2-stat">ON</span>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer, torch, door;
        let yaw = new THREE.Object3D(), pitch = new THREE.Object3D();
        let moveF = 0, moveR = 0, isSprinting = false;
        let colliders = [], interactables = [];
        let room1Light, room2Light, switch1, switch2;

        init();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.08);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            yaw.add(pitch); pitch.add(camera); scene.add(yaw);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Ambient Light (Very Dim)
            scene.add(new THREE.AmbientLight(0xffffff, 0.05));

            // FLOOR
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(60, 60), new THREE.MeshStandardMaterial({ color: 0x1a1a1a }));
            floor.rotation.x = -Math.PI/2; floor.position.y = -2; floor.receiveShadow = true;
            scene.add(floor);

            // ROOM 1 LIGHT
            room1Light = new THREE.PointLight(0xffffff, 0.8, 15);
            room1Light.position.set(0, 3, -7);
            scene.add(room1Light);

            // ROOM 2 LIGHT
            room2Light = new THREE.PointLight(0xffffff, 0.8, 20);
            room2Light.position.set(0, 3, 10);
            scene.add(room2Light);

            // WALLS & COLLIDERS
            createWall(0, 1, -15, 20, 6); // Back R1
            createWall(-10, 1, 0, 30, 6, true); // Left
            createWall(10, 1, 0, 30, 6, true); // Right
            createWall(-6, 1, 0, 8, 6); // Mid Left
            createWall(6, 1, 0, 8, 6); // Mid Right
            createWall(0, 4.5, 0, 4, 3); // Above Door

            // DOOR
            door = new THREE.Mesh(new THREE.BoxGeometry(4, 5, 0.2), new THREE.MeshStandardMaterial({color: 0x4d2a1e}));
            door.position.set(0, 0.5, 0); door.userData = { type: 'door', isOpen: false };
            scene.add(door); colliders.push(door); interactables.push(door);

            // SWITCHES (Small Cubes on Walls)
            switch1 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 0.1), new THREE.MeshStandardMaterial({color: 0xffffff}));
            switch1.position.set(-2, 0.5, -0.1); switch1.userData = { type: 'switch', room: 1 };
            scene.add(switch1); interactables.push(switch1);

            switch2 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 0.1), new THREE.MeshStandardMaterial({color: 0xffffff}));
            switch2.position.set(2, 0.5, 0.1); switch2.userData = { type: 'switch', room: 2 };
            scene.add(switch2); interactables.push(switch2);

            // FURNITURE
            createFurniture(0, -1, -8, 3, 0.2, 2, 0x4a2c16); // R1 Table
            createFurniture(5, -1, 8, 3, 1.5, 2, 0x333333); // R2 Sofa
            createFurniture(-7, 0, 12, 2, 4, 1, 0x221105); // R2 Cupboard

            // TORCH
            torch = new THREE.SpotLight(0xffffff, 40);
            torch.angle = Math.PI/7; torch.castShadow = true;
            camera.add(torch); torch.target.position.set(0, 0, -1); camera.add(torch.target);

            setupControls();
            animate();
        }

        function createWall(x, y, z, w, h, rotate=false) {
            const wall = new THREE.Mesh(new THREE.PlaneGeometry(w, h), new THREE.MeshStandardMaterial({ color: 0x444444 }));
            wall.position.set(x, y, z);
            if(rotate) wall.rotation.y = Math.PI/2;
            scene.add(wall);
            const box = new THREE.Mesh(new THREE.BoxGeometry(rotate?0.5:w, h, rotate?w:0.5));
            box.position.set(x, y, z); box.visible = false;
            scene.add(box); colliders.push(box);
        }

        function createFurniture(x, y, z, w, h, d, col) {
            const obj = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({ color: col }));
            obj.position.set(x, y, z); obj.castShadow = true; scene.add(obj); colliders.push(obj);
        }

        function setupControls() {
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if(key === 'w') moveF = 1; if(key === 's') moveF = -1;
                if(key === 'a') moveR = -1; if(key === 'd') moveR = 1;
                if(e.code === 'Space') isSprinting = true;
                if(key === 'f') torch.visible = !torch.visible;
                if(key === 'h') interact();
            });
            document.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                if(['w','s'].includes(key)) moveF = 0; if(['a','d'].includes(key)) moveR = 0;
                if(e.code === 'Space') isSprinting = false;
            });
            document.addEventListener('pointermove', (e) => {
                if(document.pointerLockElement) {
                    yaw.rotation.y -= e.movementX * 0.002;
                    pitch.rotation.x -= e.movementY * 0.002;
                    pitch.rotation.x = Math.max(-1.5, Math.min(1.5, pitch.rotation.x));
                }
            });
            document.addEventListener('mousedown', () => document.body.requestPointerLock());
        }

        function interact() {
            interactables.forEach(obj => {
                if(yaw.position.distanceTo(obj.position) < 4) {
                    if(obj.userData.type === 'door') {
                        obj.userData.isOpen = !obj.userData.isOpen;
                        obj.position.x = obj.userData.isOpen ? 4 : 0;
                        if(obj.userData.isOpen) colliders = colliders.filter(c => c !== door);
                        else colliders.push(door);
                        showMessage(obj.userData.isOpen ? "DOOR OPENED" : "DOOR CLOSED");
                    }
                    if(obj.userData.type === 'switch') {
                        if(obj.userData.room === 1) {
                            room1Light.visible = !room1Light.visible;
                            document.getElementById('r1-stat').innerText = room1Light.visible ? "ON" : "OFF";
                        } else {
                            room2Light.visible = !room2Light.visible;
                            document.getElementById('r2-stat').innerText = room2Light.visible ? "ON" : "OFF";
                        }
                        showMessage("SWITCH TOGGLED");
                    }
                }
            });
        }

        function showMessage(t) {
            const m = document.getElementById('msg');
            m.innerText = t; m.style.display = 'block';
            setTimeout(() => m.style.display = 'none', 1500);
        }

        function animate() {
            requestAnimationFrame(animate);
            let speed = isSprinting ? 0.20 : 0.08;
            if(moveF || moveR) {
                const dir = new THREE.Vector3(moveR, 0, -moveF).normalize().applyQuaternion(yaw.quaternion);
                const nextPos = yaw.position.clone().addScaledVector(dir, speed);
                let canMove = true;
                const pBox = new THREE.Box3().setFromCenterAndSize(nextPos, new THREE.Vector3(1, 4, 1));
                for(let obj of colliders) { if(pBox.intersectsBox(new THREE.Box3().setFromObject(obj))) { canMove = false; break; } }
                if(canMove) yaw.position.copy(nextPos);
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
